---
layout: post
category: "ml"
title: "海量数据相似数据查找方法"
tags: [topknn, min hash, lsh, simhash, annoy]
---

参考[海量数据相似查找系列1 -- Minhashing & LSH & Simhash 技术汇总](http://blog.csdn.net/hero_fantao/article/details/70245284)

[海量数据相似查找系列2 -- Annoy算法](http://blog.csdn.net/hero_fantao/article/details/70245387)


## Annoy

github: [https://github.com/spotify/annoy](https://github.com/spotify/annoy)

Annoy的目标是建立一个数据结构，使得**查询一个点的最近邻点的时间复杂度是次线性。**Annoy 通过建立一个二叉树来使得每个点查找时间复杂度是O(log n)。 

### 建树过程

+ 随机选择两个点，以这两个节点为初始中心节点，执行聚类数为2的kmeans过程，最终产生收敛后两个聚类中心点。
+ 这两个聚类中心点之间连一条线段（灰色短线），建立一条垂直于这条灰线，并且通过灰线中心点的线（黑色粗线）。这条黑色粗线把数据空间分成两部分。在多维空间的话，这条黑色粗线可以看成等距垂直超平面。
+ 在划分的子空间内进行不停的递归迭代继续划分，知道每个子空间最多只剩下K个数据节点。
+ 通过多次递归迭代划分的话，最终原始数据会形成类似下面这样一个二叉树结构。二叉树底层是叶子节点记录原始数据节点，其他中间节点记录的是分割超平面的信息。Annoy建立这样的二叉树结构是希望满足这样的一个假设:  相似的数据节点应该在二叉树上位置更接近，一个分割超平面不应该把相似的数据节点分割二叉树的不同分支上。

### 查询过程

查找的过程就是不断看他在分割超平面的哪一边。从二叉树索引结构来看，就是从根节点不停的往叶子节点遍历的过程。通过对二叉树每个中间节点（分割超平面相关信息）和查询数据节点进行相关计算来确定二叉树遍历过程是往这个中间节点左孩子节点走还是右孩子节点走。通过以上方式完成查询过程。

### 查询中的问题与解决方法

+ 问题1：查询过程最终落到叶子节点的数据节点数小于 我们需要的Top N相似邻居节点数目怎么办？
+ 问题2：两个相近的数据节点划分到二叉树不同分支上怎么办？

解决方法：

+ 如果分割超平面的两边都很相似，那可以两边都遍历。
+ 建立多棵二叉树树，构成一个森林，每个树建立机制都如上面所述那样。
+ 采用优先队列机制：采用一个优先队列来遍历二叉树，从根节点往下的路径，根据查询节点与当前分割超平面距离（margin）进行排序。

### 返回最终近邻节点

每棵树都返回一堆近邻点后，如何得到最终的Top N相似集合呢？
首先所有树返回近邻点都插入到优先队列中，求并集去重, 然后计算和查询点距离， 最终根据距离值从近距离到远距离排序， 返回Top N近邻节点集合。


### 性能对比

<html>
<br/>

<img src='../assets/ann-benchmark.png' style='max-height: 400px'/>
<br/>

</html>


